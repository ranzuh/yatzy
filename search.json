[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "yatzy_dup1.html",
    "href": "yatzy_dup1.html",
    "title": "Yatzy RL environment",
    "section": "",
    "text": "Yatzy program to play with and get policy and probabilities\nFeatures\nGetting probabilities\nValue iteration framework naturally gives us expected values (average scores), but if we want the full probability distribution of outcomes, we have a couple of options:\nThe first approach is more exact but computationally intensive. The second is simpler to implement and often sufficient.\nI‚Äôve decided on following state representation\nValue function could be a dict:\nPlan to Start:\ncategories\n\nfrozenset({'chance',\n           'fives',\n           'four_same',\n           'fours',\n           'full_house',\n           'large_straight',\n           'one_pair',\n           'ones',\n           'sixes',\n           'small_straight',\n           'three_same',\n           'threes',\n           'two_pairs',\n           'twos',\n           'yatzy'})\n# dice values\ndice_vals = [5, 4, 3, 2, 1]\nsorted_vals = tuple(sorted(dice_vals))\nsorted_vals\n\n(1, 2, 3, 4, 5)\nscore = sum(sorted_vals)\nscore\n\n15\nrandom.choices([1,2,3,4,5,6], k=5)\n\n[3, 1, 6, 3, 4]\nsource",
    "crumbs": [
      "Yatzy RL environment"
    ]
  },
  {
    "objectID": "yatzy_dup1.html#planning-more-about-how-to-represent-state-and-actions",
    "href": "yatzy_dup1.html#planning-more-about-how-to-represent-state-and-actions",
    "title": "Yatzy RL environment",
    "section": "Planning more about how to represent state and actions",
    "text": "Planning more about how to represent state and actions\nOkay, thinking about actions.\nI would have 2 rolls left.\nI can choose what dices to hold and which to re-roll. So basically 5 long binary word.\nI can also choose small straight category, but no chance as its taken already.\nI can also choose to set zero to any category that I‚Äôve not taken already.\nso action could be like\naction = [00000, \"small_straight\", None]\n# or\naction = [11000, None, None]\n# or\naction = [00000, None, \"ones\"]\nI need to have a function to compute possible actions. * allow re-roll if ‚Äúrolls left‚Äù is &gt; 0 * check which categories can be selected * which categories could be set to zero",
    "crumbs": [
      "Yatzy RL environment"
    ]
  },
  {
    "objectID": "yatzy_dup1.html#back-to-implementing",
    "href": "yatzy_dup1.html#back-to-implementing",
    "title": "Yatzy RL environment",
    "section": "Back to implementing",
    "text": "Back to implementing\n\nsource\n\nState\n\n State (dice_values:tuple[int,...], rolls_left:int,\n        categories_picked:frozenset[str])\n\n\nstate = State((1, 2, 3, 4, 5), 2, frozenset({'chance', 'large_straight', 'yatzy'}))\nstate\n\nState(dice_values=(1, 2, 3, 4, 5), rolls_left=2, categories_picked=frozenset({'chance', 'large_straight', 'yatzy'}))\n\n\n\nsource\n\n\nAction\n\n Action (type:Literal['reroll','score'], value:tuple[int,...]|str)\n\n\nAction(\"reroll\", (0,0,1,0,0))\n\nAction(type='reroll', value=(0, 0, 1, 0, 0))\n\n\n\nAction(\"score\", \"ones\")\n\nAction(type='score', value='ones')\n\n\n\nreroll_masks\n\n[(0, 0, 0, 0, 0),\n (0, 0, 0, 0, 1),\n (0, 0, 0, 1, 0),\n (0, 0, 0, 1, 1),\n (0, 0, 1, 0, 0),\n (0, 0, 1, 0, 1),\n (0, 0, 1, 1, 0),\n (0, 0, 1, 1, 1),\n (0, 1, 0, 0, 0),\n (0, 1, 0, 0, 1),\n (0, 1, 0, 1, 0),\n (0, 1, 0, 1, 1),\n (0, 1, 1, 0, 0),\n (0, 1, 1, 0, 1),\n (0, 1, 1, 1, 0),\n (0, 1, 1, 1, 1),\n (1, 0, 0, 0, 0),\n (1, 0, 0, 0, 1),\n (1, 0, 0, 1, 0),\n (1, 0, 0, 1, 1),\n (1, 0, 1, 0, 0),\n (1, 0, 1, 0, 1),\n (1, 0, 1, 1, 0),\n (1, 0, 1, 1, 1),\n (1, 1, 0, 0, 0),\n (1, 1, 0, 0, 1),\n (1, 1, 0, 1, 0),\n (1, 1, 0, 1, 1),\n (1, 1, 1, 0, 0),\n (1, 1, 1, 0, 1),\n (1, 1, 1, 1, 0),\n (1, 1, 1, 1, 1)]\n\n\n\navailable_actions = []\nif state.rolls_left &gt; 0:\n    rerolls = [Action(\"reroll\", mask) for mask in reroll_masks]\n    available_actions.extend(rerolls)\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 0)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 0, 0)),\n Action(type='reroll', value=(0, 0, 1, 0, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 0)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 0, 0, 0)),\n Action(type='reroll', value=(0, 1, 0, 0, 1)),\n Action(type='reroll', value=(0, 1, 0, 1, 0)),\n Action(type='reroll', value=(0, 1, 0, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 0, 0)),\n Action(type='reroll', value=(0, 1, 1, 0, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 0)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 0, 0, 0, 0)),\n Action(type='reroll', value=(1, 0, 0, 0, 1)),\n Action(type='reroll', value=(1, 0, 0, 1, 0)),\n Action(type='reroll', value=(1, 0, 0, 1, 1)),\n Action(type='reroll', value=(1, 0, 1, 0, 0)),\n Action(type='reroll', value=(1, 0, 1, 0, 1)),\n Action(type='reroll', value=(1, 0, 1, 1, 0)),\n Action(type='reroll', value=(1, 0, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 0, 0, 0)),\n Action(type='reroll', value=(1, 1, 0, 0, 1)),\n Action(type='reroll', value=(1, 1, 0, 1, 0)),\n Action(type='reroll', value=(1, 1, 0, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 0, 0)),\n Action(type='reroll', value=(1, 1, 1, 0, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 0)),\n Action(type='reroll', value=(1, 1, 1, 1, 1))]\n\n\n\ncan_select = categories - state.categories_picked\ncan_select\n\nfrozenset({'fives',\n           'four_same',\n           'fours',\n           'full_house',\n           'one_pair',\n           'ones',\n           'sixes',\n           'small_straight',\n           'three_same',\n           'threes',\n           'two_pairs',\n           'twos'})\n\n\n\nsource\n\n\nscore_ns\n\n score_ns (n, values)\n\n\nsource\n\n\nscore_n_same\n\n score_n_same (n, values)\n\n\nsource\n\n\nn_same\n\n n_same (n, values)\n\n\nsource\n\n\nscore_two_pairs\n\n score_two_pairs (values)\n\n\nsource\n\n\nscore_full_house\n\n score_full_house (values)\n\n\nsource\n\n\nscore_large_straight\n\n score_large_straight (values)\n\n\nsource\n\n\nscore_small_straight\n\n score_small_straight (values)\n\n\nfor category in can_select:\n    score = score_fn[category](state.dice_values)\n    print(category, score)\n\nfour_same 0\nthree_same 0\nthrees 3\nsmall_straight 15\nfours 4\nfives 5\nsixes 0\nones 1\none_pair 0\ntwo_pairs 0\nfull_house 0\ntwos 2\n\n\n\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 0)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 0, 0)),\n Action(type='reroll', value=(0, 0, 1, 0, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 0)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 0, 0, 0)),\n Action(type='reroll', value=(0, 1, 0, 0, 1)),\n Action(type='reroll', value=(0, 1, 0, 1, 0)),\n Action(type='reroll', value=(0, 1, 0, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 0, 0)),\n Action(type='reroll', value=(0, 1, 1, 0, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 0)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 0, 0, 0, 0)),\n Action(type='reroll', value=(1, 0, 0, 0, 1)),\n Action(type='reroll', value=(1, 0, 0, 1, 0)),\n Action(type='reroll', value=(1, 0, 0, 1, 1)),\n Action(type='reroll', value=(1, 0, 1, 0, 0)),\n Action(type='reroll', value=(1, 0, 1, 0, 1)),\n Action(type='reroll', value=(1, 0, 1, 1, 0)),\n Action(type='reroll', value=(1, 0, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 0, 0, 0)),\n Action(type='reroll', value=(1, 1, 0, 0, 1)),\n Action(type='reroll', value=(1, 1, 0, 1, 0)),\n Action(type='reroll', value=(1, 1, 0, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 0, 0)),\n Action(type='reroll', value=(1, 1, 1, 0, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 0)),\n Action(type='reroll', value=(1, 1, 1, 1, 1))]\n\n\n\nfor cat in can_select:\n    score = score_fn[cat](state.dice_values)\n    available_actions.append(Action(type=\"score\", value=cat))\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 0)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 0, 0)),\n Action(type='reroll', value=(0, 0, 1, 0, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 0)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 0, 0, 0)),\n Action(type='reroll', value=(0, 1, 0, 0, 1)),\n Action(type='reroll', value=(0, 1, 0, 1, 0)),\n Action(type='reroll', value=(0, 1, 0, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 0, 0)),\n Action(type='reroll', value=(0, 1, 1, 0, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 0)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 0, 0, 0, 0)),\n Action(type='reroll', value=(1, 0, 0, 0, 1)),\n Action(type='reroll', value=(1, 0, 0, 1, 0)),\n Action(type='reroll', value=(1, 0, 0, 1, 1)),\n Action(type='reroll', value=(1, 0, 1, 0, 0)),\n Action(type='reroll', value=(1, 0, 1, 0, 1)),\n Action(type='reroll', value=(1, 0, 1, 1, 0)),\n Action(type='reroll', value=(1, 0, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 0, 0, 0)),\n Action(type='reroll', value=(1, 1, 0, 0, 1)),\n Action(type='reroll', value=(1, 1, 0, 1, 0)),\n Action(type='reroll', value=(1, 1, 0, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 0, 0)),\n Action(type='reroll', value=(1, 1, 1, 0, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 0)),\n Action(type='reroll', value=(1, 1, 1, 1, 1)),\n Action(type='score', value='four_same'),\n Action(type='score', value='three_same'),\n Action(type='score', value='threes'),\n Action(type='score', value='small_straight'),\n Action(type='score', value='fours'),\n Action(type='score', value='fives'),\n Action(type='score', value='sixes'),\n Action(type='score', value='ones'),\n Action(type='score', value='one_pair'),\n Action(type='score', value='two_pairs'),\n Action(type='score', value='full_house'),\n Action(type='score', value='twos')]\n\n\n\nsource\n\n\nget_available_actions\n\n get_available_actions (state:__main__.State)\n\n\nget_available_actions(state)\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 0)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 0, 0)),\n Action(type='reroll', value=(0, 0, 1, 0, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 0)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 0, 0, 0)),\n Action(type='reroll', value=(0, 1, 0, 0, 1)),\n Action(type='reroll', value=(0, 1, 0, 1, 0)),\n Action(type='reroll', value=(0, 1, 0, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 0, 0)),\n Action(type='reroll', value=(0, 1, 1, 0, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 0)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 0, 0, 0, 0)),\n Action(type='reroll', value=(1, 0, 0, 0, 1)),\n Action(type='reroll', value=(1, 0, 0, 1, 0)),\n Action(type='reroll', value=(1, 0, 0, 1, 1)),\n Action(type='reroll', value=(1, 0, 1, 0, 0)),\n Action(type='reroll', value=(1, 0, 1, 0, 1)),\n Action(type='reroll', value=(1, 0, 1, 1, 0)),\n Action(type='reroll', value=(1, 0, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 0, 0, 0)),\n Action(type='reroll', value=(1, 1, 0, 0, 1)),\n Action(type='reroll', value=(1, 1, 0, 1, 0)),\n Action(type='reroll', value=(1, 1, 0, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 0, 0)),\n Action(type='reroll', value=(1, 1, 1, 0, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 0)),\n Action(type='reroll', value=(1, 1, 1, 1, 1)),\n Action(type='score', value='four_same'),\n Action(type='score', value='three_same'),\n Action(type='score', value='threes'),\n Action(type='score', value='small_straight'),\n Action(type='score', value='fours'),\n Action(type='score', value='fives'),\n Action(type='score', value='sixes'),\n Action(type='score', value='ones'),\n Action(type='score', value='one_pair'),\n Action(type='score', value='two_pairs'),\n Action(type='score', value='full_house'),\n Action(type='score', value='twos')]\n\n\nWhat I have\n\nstate representation\naction representation\ncategories\ndice rolling\nfunctions to check if dice values fit category\navailable actions function\n\nWhat is missing * transition function * logic for reroll * logic for selecting zeroing categories\nTransition function\nstate + action ‚Äì&gt; next state\nnext_state = transition_func(state, action)\nWhat transitions are there?\nAction types: * reroll * zero * score\nreroll * reroll the dice according to mask * set new dice to state * decrement rolls left\nzero * set the category as selected * check wheter categories left and set terminal state if not any left * reroll whole dice * reset rolls left to 2\nscore * compute score * set the category as selected * add score to scoreboard or total sum * check wheter categories left and set terminal state if not any left * reroll whole dice * reset rolls left to 2\nLet‚Äôs have a state and action to work with.\n\nstate\n\nState(dice_values=(1, 2, 3, 4, 5), rolls_left=2, categories_picked=frozenset({'chance', 'large_straight', 'yatzy'}))\n\n\n\naction = Action(type='reroll', value=(1, 1, 1, 0, 0))\naction\n\nAction(type='reroll', value=(1, 1, 1, 0, 0))\n\n\nWhat it would mean to transition to next state given this state and action?\n\nsource\n\n\nreroll_masked\n\n reroll_masked (values, mask)\n\n\nreroll_masked((1,2,3,4,5), (1,1,1,0,0))\n\n(4, 4, 5, 5, 6)\n\n\n\nsource\n\n\ntransition_func\n\n transition_func (state:__main__.State, action:__main__.Action)\n\n\ntransition_func(state, action)\n\nState(dice_values=(1, 2, 3, 4, 5), rolls_left=1, categories_picked=frozenset({'chance', 'large_straight', 'yatzy'}))\n\n\n\ntransition_func(state, Action(\"score\", \"ones\"))\n\nState(dice_values=(1, 2, 2, 6, 6), rolls_left=2, categories_picked=frozenset({'chance', 'ones', 'large_straight', 'yatzy'}))\n\n\nstate = State(sorted(roll_n_dice(5)), 2, frozenset()) while True: actions = get_available_actions(state) # for i, action in enumerate(actions): print(i, action) print(f‚ÄùState: {state}, choose action (i) or quit (q)‚Äú) inp = input(‚Äù&gt;‚Äú) if inp ==‚Äùq‚Äù: break\nif inp.isdigit():\n    action = Action(\"reroll\", tuple(int(i) for i in inp))\nelse:\n    action = Action(\"score\", inp)\n\nassert action in actions\n\n# idx = int(inp)\nstate = transition_func(state, action)\n\n!cat yatzy/yatzy.py\n\n# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/yatzy_dup1.ipynb.\n\n# %% auto 0\n__all__ = ['categories', 'reroll_masks', 'checkers', 'roll_n_dice', 'State', 'Action', 'has_ns', 'n_same', 'has_n_same',\n           'has_two_pairs', 'has_full_house', 'has_small_straight', 'has_large_straight', 'get_available_actions',\n           'reroll_masked', 'transition_func']\n\n# %% ../nbs/yatzy_dup1.ipynb 5\nimport random\nfrom dataclasses import dataclass\nfrom typing import Literal\nimport itertools\nfrom collections import Counter\nfrom functools import partial\n\n# %% ../nbs/yatzy_dup1.ipynb 6\n# categories\n\ncategories = frozenset([\n    \"ones\",\n    \"twos\",\n    \"threes\",\n    \"fours\",\n    \"fives\",\n    \"sixes\",\n    \"one_pair\",\n    \"two_pairs\",\n    \"three_same\",\n    \"four_same\",\n    \"small_straight\",\n    \"large_straight\",\n    \"full_house\",\n    \"chance\",\n    \"yatzy\",\n])\n\n# %% ../nbs/yatzy_dup1.ipynb 11\ndef roll_n_dice(n):\n    return random.choices([1,2,3,4,5,6], k=n)\n\n# %% ../nbs/yatzy_dup1.ipynb 16\n@dataclass\nclass State:\n    dice_values: tuple[int, ...]\n    rolls_left: int\n    categories_picked: frozenset[str]\n\n# %% ../nbs/yatzy_dup1.ipynb 18\n@dataclass\nclass Action:\n    type: Literal[\"reroll\", \"score\", \"zero\"]\n    value: tuple[int, ...] | str\n\n# %% ../nbs/yatzy_dup1.ipynb 20\nreroll_masks = list(itertools.product((0,1), repeat=5))\n\n# %% ../nbs/yatzy_dup1.ipynb 33\ndef has_ns(n, values):\n    return n in values\n\nassert has_ns(3, (1,2,3,4,5))\nassert not has_ns(6, (1,2,3,4,5))\n\ndef n_same(n, values):\n    counts = Counter(values)\n    return [k for k, v in counts.items() if v &gt;= n]\n\nassert n_same(2, (1,2,2,3,3)) == [2, 3]\n\ndef has_n_same(n, values):\n    return bool(n_same(n, values))\n\ndef has_two_pairs(values):\n    pairs = n_same(2, values)\n    if len(pairs) == 2:\n        return True\n    return False\n\nassert has_two_pairs((1,1,2,2,3))\nassert not has_two_pairs((1,1,2,3,4))\nassert not has_two_pairs((1,1,1,1,2))\n\ndef has_full_house(values):\n    pairs = n_same(2, values)\n    three_sames = n_same(3, values)\n    if pairs and three_sames:\n        pairs.remove(three_sames[0])\n        return len(pairs) &gt; 0\n    return False\n\nassert has_full_house((2,2,3,3,3))\nassert not has_full_house((1,2,3,3,3))\n\ndef has_small_straight(values):\n    return values == (1,2,3,4,5)\n\ndef has_large_straight(values):\n    return values == (2,3,4,5,6)\n\n# %% ../nbs/yatzy_dup1.ipynb 35\ncheckers = {\n    \"ones\": partial(has_ns, 1),\n    \"twos\": partial(has_ns, 2),\n    \"threes\": partial(has_ns, 3),\n    \"fours\": partial(has_ns, 4),\n    \"fives\": partial(has_ns, 5),\n    \"sixes\": partial(has_ns, 6),\n    \"one_pair\": partial(has_n_same, 2),\n    \"two_pairs\": has_two_pairs,\n    \"three_same\": partial(has_n_same, 3),\n    \"four_same\": partial(has_n_same, 4),\n    \"small_straight\": has_small_straight,\n    \"large_straight\": has_large_straight,\n    \"full_house\": has_full_house,\n    \"chance\": lambda x: x, # ???\n    \"yatzy\": partial(n_same, 5),\n}\n\n# %% ../nbs/yatzy_dup1.ipynb 39\ndef get_available_actions(state: State) -&gt; list[Action]:\n    available_actions = []\n    if state.rolls_left &gt; 0:\n        rerolls = [Action(\"reroll\", mask) for mask in reroll_masks]\n        available_actions.extend(rerolls)\n    \n    can_zero = categories - state.categories_picked\n    for cat in can_zero:\n        available_actions.append(Action(type=\"zero\", value=cat))\n        can_select = checkers[cat](state.dice_values)\n        if can_select:\n            available_actions.append(Action(type=\"score\", value=cat))\n    \n    return available_actions\n\n# %% ../nbs/yatzy_dup1.ipynb 46\ndef reroll_masked(values, mask):\n    next_values = list(values)\n    mask = action.value\n    reroll = roll_n_dice(5)\n    for i, bit in enumerate(mask):\n        if bit == 1:\n            next_values[i] = reroll[i]\n    return tuple(sorted(next_values))\n\n# %% ../nbs/yatzy_dup1.ipynb 48\ndef transition_func(state: State, action: Action):\n    match action.type:\n        case \"reroll\":\n            assert state.rolls_left &gt; 0\n            new_values = reroll_masked(state.dice_values, action.value)\n            return State(new_values, state.rolls_left - 1, state.categories_picked)\n        case \"score\": ...\n        case \"zero\":\n            assert action.value not in state.categories_picked\n            new_categories = state.categories_picked | {action.value}\n            categories_left = categories - state.categories_picked\n            if not categories_left: return TERMINAL_STATE\n            new_values = tuple(sorted(roll_n_dice(5)))\n            return State(new_values, 2, frozenset(new_categories))",
    "crumbs": [
      "Yatzy RL environment"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "yatzy",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "yatzy"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "yatzy",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall yatzy in Development mode\n# make sure yatzy package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to yatzy\n$ nbdev_prepare",
    "crumbs": [
      "yatzy"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "yatzy",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/ranzuh/yatzy.git\nor from conda\n$ conda install -c ranzuh yatzy\nor from pypi\n$ pip install yatzy\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository‚Äôs pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "yatzy"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "yatzy",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don‚Äôt forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "yatzy"
    ]
  },
  {
    "objectID": "yatzy.html#initial-planning",
    "href": "yatzy.html#initial-planning",
    "title": "or",
    "section": "Initial planning",
    "text": "Initial planning\nYatzy program to play with and get policy and probabilities\nShould have * encoding state * transition function for rules * checking terminal state and computing reward * actions to roll dice and select categories * value iteration to compute value function / policy\nI want to create a yatzy program that I‚Äôve stated above. Am I missing anything?\n\nü§ñReplyü§ñ\nGreat project! Your list covers the key components for a Yatzy reinforcement learning setup. Let me check if you‚Äôve got everything:\nWhat you have: - State encoding ‚úì - Transition function (rules) ‚úì - Terminal state and reward ‚úì - Actions ‚úì\nYou might also want to consider: - A scoring function for each category (ones, twos, full house, etc.) - How to handle the scorecard state (which categories have been used) - The reroll mechanism (you get up to 3 rolls per turn, choosing which dice to keep) - Whether you‚Äôre implementing single-player (maximize your score) or multi-player (beat opponents)\nFor value iteration specifically, you‚Äôll need a value function that estimates the expected score from any state.\nWhat‚Äôs your vision for the game? Single-player trying to maximize score, or competitive play? And do you already have a sense of how you want to encode the state?\nI think I could start with a single player setting. What if I want to get probability of each outcome? Should I use markov chains for that or can I use same setup I‚Äôm designing to easily get that?\n\n\nü§ñReplyü§ñ\nGood question! You can actually use the same setup for both.\nYour value iteration framework naturally gives you expected values (average scores), but if you want the full probability distribution of outcomes, you have a couple of options:\n\nExtend your existing transition function - Since you‚Äôre already building transitions (state ‚Üí action ‚Üí next state), you can track probabilities through these transitions. This is essentially using the Markov chain structure you‚Äôre already creating.\nMonte Carlo simulation - Once you have your optimal policy, you can run many simulations and collect the distribution of final scores empirically.\n\nThe first approach is more exact but computationally intensive. The second is simpler to implement and often sufficient.\nWhich sounds more appealing to you? And have you thought about how you want to represent your state yet (dice values, roll number, which categories are filled)?\nState should have * current dice values * roll number, or rolls left, same thing I guess * which categories are filled\ndo you think thats sufficient for state?\n\n\nü§ñReplyü§ñ\nYes, that‚Äôs sufficient for the state! You‚Äôve captured all the information needed to make optimal decisions:\n\nCurrent dice values - what you‚Äôre working with right now\nRolls left - determines whether you can reroll or must score\nFilled categories - which scoring options are still available\n\nOne small implementation detail to consider: how will you represent the dice? For example, [1, 2, 3, 3, 5] vs.¬†a sorted version [1, 2, 3, 3, 5] vs.¬†counts {1:1, 2:1, 3:2, 5:1}. Sorting or using counts can reduce your state space significantly since [1, 2, 3, 3, 5] and [3, 1, 5, 3, 2] are functionally identical.\nHave you thought about how you want to represent the dice values?\nSorted version is best. Rolls left can just be 2,1,0. Hmm categories filled. What options I have, a binary number or list?\n\n\nü§ñReplyü§ñ\nGood choices! Sorted dice and rolls left as 2, 1, 0 are clean.\nFor categories filled, both options work:\nBinary number (e.g., 0b1010110101) - compact, efficient for hashing/lookup, but less readable\nList/set (e.g., ['ones', 'full_house'] or {0, 3, 5}) - more readable, easier to debug\nTuple of booleans (e.g., (True, False, True, ...)) - middle ground, hashable for dictionaries\nThe binary number is probably best for value iteration since you‚Äôll have lots of states to store. You can use bit operations to check/set categories quickly.\nHow many categories are you including? Standard Yatzy has 15 (6 upper section + 9 lower section). Are you doing full rules or a simplified version?\nFull rules. Should I use numpy for storing state, it has bit operations also, right?\n\n\nü§ñReplyü§ñ\nYes, numpy has bitwise operations (&, |, ^, ~, &lt;&lt;, &gt;&gt;), but for storing state in value iteration, you might not need numpy arrays specifically.\nHere‚Äôs why: your state is more like a key for looking up values in a dictionary, not a large array of numbers. Python‚Äôs built-in int for the binary categories works great with bitwise ops, and you can use a regular dict or numpy array indexed by state.\nFor example: - Categories as int: categories = 0b0001010 - Check if category 2 is filled: categories & (1 &lt;&lt; 2) - Mark category 2 as filled: categories | (1 &lt;&lt; 2)\nYou might use numpy for dice operations (rolling, sorting) or storing your value function as an array if you enumerate all states.\nAre you planning to enumerate all possible states upfront, or build them dynamically as you explore?\nEnumerate up front. I think its common to represent states with int, like in gymnasium discrete? Do you think its better to use dict with state as key?\n\n\nü§ñReplyü§ñ\nGood point! Yes, in Gymnasium‚Äôs discrete spaces, states are typically integers (0, 1, 2, ‚Ä¶, n). This works well when you can map your full state to a unique integer.\nFor your case, you could create a mapping function: - Dice (sorted) ‚Üí some integer - Rolls left (0-2) ‚Üí multiply by some factor - Categories (binary) ‚Üí shift and add\nThen use a numpy array indexed by this state integer for your value function: V[state_int].\nTradeoff: - Int indexing + numpy array: faster lookup, more cache-friendly - Dict with tuple key: easier to debug (you can see (dice, rolls, categories) directly), simpler mapping\nSince you‚Äôre enumerating upfront and want performance for value iteration, the integer state indexing is probably better.\nDo you want to start sketching out how to encode your state as an integer, or would you like to begin with a simpler piece first (like the dice rolling or scoring functions)?\nActually, when I think about it now having\nstate = (dice, rolls, categories)\nvalue = V[state]\nlooks very clean. That‚Äôs the dict approach right?\n\n\nü§ñReplyü§ñ\nExactly! That‚Äôs the dict approach:\nV = {}  # or defaultdict\nstate = (tuple(sorted_dice), rolls_left, categories_int)\nvalue = V[state]\nThe tuple is hashable (so it works as a dict key), and you‚Äôre right‚Äîit‚Äôs very clean and readable. You can directly see what each state represents when debugging.\nThe performance difference between dict and array indexing probably won‚Äôt matter much unless you‚Äôre doing millions of iterations. And dict has a nice bonus: you only store states you actually visit, which could save memory.\nSounds like you have a good plan! What would you like to tackle first‚Äîthe state encoding, the scoring functions, or the transition/action logic?\nCan you give me the readable options for categories that would work well with the dict approach?\n\n\nü§ñReplyü§ñ\nSure! Here are some readable options for categories:\nOption 1: Named tuple or dict keys\ncategories = {'ones': True, 'twos': False, 'threes': True, ...}\nOption 2: Set of used categories\ncategories = {'ones', 'full_house', 'chance'}  # just the filled ones\nOption 3: Frozenset (hashable set)\ncategories = frozenset(['ones', 'full_house'])  # can be dict key\nFor your dict state approach, Option 3 (frozenset) works best because: - It‚Äôs hashable (required for dict keys) - You only store what‚Äôs used (compact) - Easy to check: 'ones' in categories - Easy to add: categories | {'twos'}\nWould you like to use frozenset, or do you prefer keeping the binary int approach for compactness?\nWhat are the differences between options 1 and 3?\n\n\nü§ñReplyü§ñ\nGood question! The key difference is hashability:\nOption 1 (dict): - {'ones': True, 'twos': False, ...} is not hashable - Can‚Äôt use it as a dict key: V[state] would fail - You‚Äôd need to convert it (e.g., to a frozenset or tuple of items)\nOption 3 (frozenset): - frozenset(['ones', 'full_house']) is hashable - Works directly as dict key: V[(dice, rolls, categories)] ‚úì - Immutable (can‚Äôt accidentally modify it)\nSo Option 1 looks nice but doesn‚Äôt work for your state tuple without extra conversion. Option 3 works out of the box.\nDoes that clarify the tradeoff?\nAnother option would be to have an efficient way to store state and then have a function to get the human readable version.\n\n\nü§ñReplyü§ñ\nThat‚Äôs a smart approach! You get the best of both worlds:\nEfficient storage: Use int for categories (or even encode the whole state as one int)\nReadable debugging: Have a helper function like state_to_readable(state) that converts it when you need to inspect it\nThis is actually a common pattern in RL implementations. You could have: - encode_state(dice, rolls, categories) ‚Üí compact representation - decode_state(state) ‚Üí human-readable format\nThe compact version stays in your dict keys and value iteration, but you can always decode when debugging or analyzing results.\nDo you want to go with this approach? And if so, would you keep categories as int and just decode those, or encode the entire state into a single int?\nIs it easy to implement later? What would be a good plan to start iterating and experimenting the quickest?\n\n\nü§ñReplyü§ñ\nGreat pragmatic question! Here‚Äôs the quickest path to start experimenting:\nStart simple, optimize later:\n\nUse the readable approach first: state = (tuple(dice), rolls_left, frozenset(categories))\nGet your basic game logic working (scoring, transitions, actions)\nTest with small examples\nIf performance becomes an issue, add encoding functions later\n\nThis way you can: - Debug easily (see exactly what‚Äôs happening) - Iterate quickly on game logic - Add the int encoding wrapper later without changing core logic\nThe encoding functions are straightforward to add once everything works. Premature optimization can slow you down.\nDoes starting with the readable version and refactoring later sound good? Or do you have performance concerns from the start?\nWhat are advantages of frozenset vs tuple or strings?\n\n\nü§ñReplyü§ñ\nGood question! Here are the key differences:\nFrozenset: - Unordered: frozenset(['ones', 'twos']) == frozenset(['twos', 'ones']) - Easy membership check: 'ones' in categories - Natural for ‚Äúwhich categories are filled‚Äù (order doesn‚Äôt matter)\nTuple: - Ordered: ('ones', 'twos') ‚â† ('twos', 'ones') - You‚Äôd need to keep it sorted to avoid duplicate states - Still hashable and works as dict key\nStrings: - Could do something like 'ones,twos,full_house' - Harder to check membership or add categories - More manual string manipulation\nFor your use case (tracking which categories are used), frozenset is most natural since the order you filled categories doesn‚Äôt matter for game state.\nDoes that help you decide which to use?",
    "crumbs": [
      "or"
    ]
  },
  {
    "objectID": "yatzy.html#summary-of-planning",
    "href": "yatzy.html#summary-of-planning",
    "title": "or",
    "section": "Summary of planning",
    "text": "Summary of planning\nOkay can you summarise all the decisions I made and have a clear plan to start working next\n\nü§ñReplyü§ñ\nYour Decisions:\n\nSingle-player Yatzy to maximize score\nState representation: (tuple(sorted_dice), rolls_left, frozenset(filled_categories))\nUse dict for value function: V[state] = value\nStart with readable format, optimize encoding later if needed\nFull Yatzy rules (15 categories)\n\nPlan to Start:\n\nDefine the 15 category names (as strings for frozenset)\nWrite scoring functions for each category\nImplement dice rolling and state transitions\nDefine valid actions (which dice to keep, which category to score)\nBuild value iteration algorithm\nTest and iterate\n\nImmediate next step: Would you like to start by defining the category names and writing a few scoring functions (like ‚Äúones‚Äù, ‚Äúfull house‚Äù, ‚Äúyatzy‚Äù)? Or would you prefer to begin with the dice rolling mechanics?\n\n# categories\n\ncategories = set([\n    \"ones\",\n    \"twos\",\n    \"threes\",\n    \"fours\",\n    \"fives\",\n    \"sixes\",\n    \"one_pair\",\n    \"two_pairs\",\n    \"three_same\",\n    \"four_same\",\n    \"small_straight\",\n    \"large_straight\",\n    \"full_house\",\n    \"chance\",\n    \"yatzy\",\n])\ncategories\n\n{'chance',\n 'fives',\n 'four_same',\n 'fours',\n 'full_house',\n 'large_straight',\n 'one_pair',\n 'ones',\n 'sixes',\n 'small_straight',\n 'three_same',\n 'threes',\n 'two_pairs',\n 'twos',\n 'yatzy'}\n\n\n\n# dice values\ndice_vals = [5, 4, 3, 2, 1]\nsorted_vals = tuple(sorted(dice_vals))\nsorted_vals\n\n(1, 2, 3, 4, 5)\n\n\n\nscore = sum(sorted_vals)\nscore\n\n15\n\n\n\nimport random\n\nrandom.choices([1,2,3,4,5,6], k=5)\n\n[1, 3, 5, 2, 3]\n\n\n\ndef roll_n_dice(n):\n    return random.choices([1,2,3,4,5,6], k=n)\n\nroll_n_dice(5)\n\n[5, 3, 2, 3, 6]\n\n\n\nstate = (sorted_vals, 2, frozenset(random.sample(sorted(categories), 3)))\nstate\n\n((1, 2, 3, 4, 5), 2, frozenset({'sixes', 'threes', 'twos'}))",
    "crumbs": [
      "or"
    ]
  },
  {
    "objectID": "yatzy.html#planning-more-about-how-to-represent-state-and-actions",
    "href": "yatzy.html#planning-more-about-how-to-represent-state-and-actions",
    "title": "or",
    "section": "Planning more about how to represent state and actions",
    "text": "Planning more about how to represent state and actions\nWhat do you think about encoding actions? What other options I could have?\n\nü§ñReplyü§ñ\nGood thinking on the action structure! Your approach captures the three types of actions. Here are some encoding options:\nOption 1: Your tuple approach\naction = (reroll_mask, score_category, zero_category)\nSimple, but only one field should be non-None at a time.\nOption 2: Tagged tuple\naction = ('reroll', [1,1,0,0,0])  # or\naction = ('score', 'small_straight')  # or\naction = ('zero', 'ones')\nMore explicit about action type.\nOption 3: Single value with different types\naction = [1,1,0,0,0]  # reroll (list/tuple)\naction = 'small_straight'  # score (string)\naction = ('zero', 'ones')  # zero out (tuple)\nPython‚Äôs dynamic typing lets you distinguish by type.\nOption 4: Integer encoding Map all possible actions to integers (0-N), like Gymnasium discrete actions.\nWhich feels most natural to you? Option 2 is probably clearest for debugging, while Option 4 would be most efficient if you need it later.\nAre there other options similar to tagged tuple?\n\n\nü§ñReplyü§ñ\nYes! Here are some similar options to tagged tuples:\nNamed tuple:\nfrom collections import namedtuple\nAction = namedtuple('Action', ['type', 'value'])\naction = Action('reroll', [1,1,0,0,0])\naction = Action('score', 'small_straight')\nDataclass:\nfrom dataclasses import dataclass\n@dataclass(frozen=True)  # frozen makes it hashable\nclass Action:\n    type: str\n    value: any\nDictionary:\naction = {'type': 'reroll', 'value': [1,1,0,0,0]}\naction = {'type': 'score', 'category': 'small_straight'}\n(Not hashable unless you convert it)\nEnum + value:\nfrom enum import Enum\nclass ActionType(Enum):\n    REROLL = 1\n    SCORE = 2\n    ZERO = 3\naction = (ActionType.REROLL, [1,1,0,0,0])\nNamed tuple and dataclass give you nice attribute access (action.type, action.value) while staying hashable. Do any of these appeal to you more than the plain tagged tuple?",
    "crumbs": [
      "or"
    ]
  },
  {
    "objectID": "yatzy.html#back-to-implementing",
    "href": "yatzy.html#back-to-implementing",
    "title": "or",
    "section": "Back to implementing",
    "text": "Back to implementing\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass State:\n    dice_values: tuple[int, ...]\n    rolls_left: int\n    categories_picked: frozenset[str]\n\nstate = State((1, 2, 3, 4, 5), 2, frozenset({'chance', 'large_straight', 'yatzy'}))\nstate\n\nState(dice_values=(1, 2, 3, 4, 5), rolls_left=2, categories_picked=frozenset({'large_straight', 'chance', 'yatzy'}))\n\n\n\nfrom typing import Literal\n\n@dataclass\nclass Action:\n    type: Literal[\"reroll\", \"score\", \"zero\"]\n    value: tuple[int, ...] | str\n\nAction(\"reroll\", (0,0,1,0,0))\n\nAction(type='reroll', value=(0, 0, 1, 0, 0))\n\n\n\nimport itertools\n\nreroll_masks = list(itertools.combinations_with_replacement((0,1), 5))\nreroll_masks\n\n[(0, 0, 0, 0, 0),\n (0, 0, 0, 0, 1),\n (0, 0, 0, 1, 1),\n (0, 0, 1, 1, 1),\n (0, 1, 1, 1, 1),\n (1, 1, 1, 1, 1)]\n\n\n\navailable_actions = []\nif state.rolls_left &gt; 0:\n    rerolls = [Action(\"reroll\", mask) for mask in reroll_masks]\n    available_actions.extend(rerolls)\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 1))]\n\n\n\ncan_zero = categories - state.categories_picked\ncan_zero\n\n{'fives',\n 'four_same',\n 'fours',\n 'full_house',\n 'one_pair',\n 'ones',\n 'sixes',\n 'small_straight',\n 'three_same',\n 'threes',\n 'two_pairs',\n 'twos'}\n\n\nI need checker functions for * has_ones, has_twos, has_threes, ‚Ä¶ I think I could have has_num(n) or something * has_pair * has_two_pairs * has_three_same * has_four_same * has_small_straight * has_large_straight * has_full_house * has_yatzy\nCan you summarise where I‚Äôm at, whats still missing?\n\nü§ñReplyü§ñ\nWhere you‚Äôre at:\n\n‚úÖ State representation (dataclass with dice, rolls_left, categories_picked)\n‚úÖ Action representation (dataclass with type and value)\n‚úÖ Category names defined\n‚úÖ Basic dice rolling function\n‚úÖ Started on available actions (reroll actions working)\n\nStill missing:\n\nChecker functions - detect patterns in dice (pairs, straights, full house, etc.)\nScoring functions - calculate points for each category given dice\nComplete available actions - add ‚Äúscore‚Äù and ‚Äúzero‚Äù actions based on what‚Äôs valid\nTransition function - apply action to state and get next state\nReward/terminal logic - when game ends and final score calculation\nValue iteration - the RL algorithm itself\n\nImmediate next step: The checker functions you listed seem like a natural next piece. Once you have those, scoring becomes straightforward.\nDo you want to start implementing the checker functions, or tackle something else first?\n\nvalues = state.dice_values\n# has ones\n1 in values\n# n in values\n\nfrom collections import Counter\n\nCounter(values)\n\nCounter({1: 1, 2: 1, 3: 1, 4: 1, 5: 1})\n\n\nHow can I use counter to get keys that have certain value?\n\n\nü§ñReplyü§ñ\nYou can filter the Counter by checking the counts:\ncounts = Counter(values)\n# Keys with count &gt;= 2\npairs = [k for k, v in counts.items() if v &gt;= 2]\nOr to check if any value has a certain count:\nhas_pair = any(count &gt;= 2 for count in counts.values())\nDoes this help you think about how to implement your checker functions?\n\ncounts = Counter((1, 1, 2, 2, 3))\n# Keys with count &gt;= 2\npairs = [k for k, v in counts.items() if v &gt;= 2]\npairs\n\n[1, 2]\n\n\n\ncounts = Counter((1, 2, 2, 2, 3))\nthree_sames = [k for k, v in counts.items() if v &gt;= 3]\nthree_sames\n\n[2]\n\n\n\ncounts = Counter((1, 5, 5, 5, 5))\nfour_sames = [k for k, v in counts.items() if v &gt;= 4]\nfour_sames\n\n[5]\n\n\n\ncounts = Counter((6,6,6,6,6))\nyatzy = [k for k, v in counts.items() if v &gt;= 5]\nyatzy\n\n[6]\n\n\n\n# Full house\ncounts = Counter((5,5,5,6,6))\npairs = [k for k, v in counts.items() if v &gt;= 2]\nthree_sames = [k for k, v in counts.items() if v &gt;= 3]\n\npairs.remove(three_sames[0])\nlen(pairs) &gt; 0\n\nTrue\n\n\n\n# small straight\nvalues = (1, 2, 3, 4, 5)\nvalues == (1, 2, 3, 4, 5)\n\n# large straight\nvalues = (2, 3, 4, 5, 6)\nvalues == (2, 3, 4, 5, 6)\n\nTrue\n\n\n\ndef has_ns(n, values):\n    return n in values\n\nassert has_ns(3, (1,2,3,4,5))\nassert not has_ns(6, (1,2,3,4,5))\n\ndef n_same(n, values):\n    counts = Counter(values)\n    return [k for k, v in counts.items() if v &gt;= n]\n\nassert n_same(2, (1,2,2,3,3)) == [2, 3]\n\ndef has_n_same(n, values):\n    return bool(n_same(n, values))\n#def has_pair(values):\n#    return n_same(values, 2)\n\n#def has_three_same(values):\n#    return n_same(values, 3)\n\n#def has_four_same(values):\n#    return n_same(values, 4)\n\n#def has_yatzy(values):\n#    return n_same(values, 5)\n\n#assert has_yatzy((1,1,1,1,1))\n#assert not has_yatzy((1,1,1,1,2))\n\ndef has_two_pairs(values):\n    pairs = n_same(2, values)\n    if len(pairs) == 2:\n        return True\n    return False\n\nassert has_two_pairs((1,1,2,2,3))\nassert not has_two_pairs((1,1,2,3,4))\nassert not has_two_pairs((1,1,1,1,2))\n\ndef has_full_house(values):\n    pairs = n_same(2, values)\n    three_sames = n_same(3, values)\n    if pairs and three_sames:\n        pairs.remove(three_sames[0])\n        return len(pairs) &gt; 0\n    return False\n\nassert has_full_house((2,2,3,3,3))\nassert not has_full_house((1,2,3,3,3))\n\ndef has_small_straight(values):\n    return values == (1,2,3,4,5)\n\ndef has_large_straight(values):\n    return values == (2,3,4,5,6)\n\n\ndef score_n(value, values): \n    n = values.count(value)\n    return value * n\nassert score_n(1, (1,1,1,2,3)) == 3\n\ndef score_same(n, values): \n    # todo\n    return value * n\n\n\ndef score_yatzy(value): return value * 5 + 50\ndef score_two_pairs(pair1, pair2): return 2 * pair1 + 2 * pair2\ndef score_full_house(pair_value, three_value): return 2 * pair_value + 3 * three_value\ndef score_small_straight(): return 15\ndef score_large_straight(): return 20\n\n\ncan_zero\n\n{'fives',\n 'four_same',\n 'fours',\n 'full_house',\n 'one_pair',\n 'ones',\n 'sixes',\n 'small_straight',\n 'three_same',\n 'threes',\n 'two_pairs',\n 'twos'}\n\n\n\nfrom functools import partial\n\ncheckers = {\n    \"ones\": partial(has_ns, 1),\n    \"twos\": partial(has_ns, 2),\n    \"threes\": partial(has_ns, 3),\n    \"fours\": partial(has_ns, 4),\n    \"fives\": partial(has_ns, 5),\n    \"sixes\": partial(has_ns, 6),\n    \"one_pair\": partial(has_n_same, 2),\n    \"two_pairs\": has_two_pairs,\n    \"three_same\": partial(has_n_same, 3),\n    \"four_same\": partial(has_n_same, 4),\n    \"small_straight\": has_small_straight,\n    \"large_straight\": has_large_straight,\n    \"full_house\": has_full_house,\n    \"chance\": lambda x: x, # ???\n    \"yatzy\": partial(n_same, 5),\n}\n\n\nfor category in can_zero:\n    can_select = checkers[category](state.dice_values)\n    print(category, can_select)\n\ntwo_pairs False\nthrees True\nsmall_straight True\nfours True\nfour_same False\none_pair False\ntwos True\nones True\nsixes False\nthree_same False\nfull_house False\nfives True\n\n\n\nscorers = {\n    \"ones\": partial(score_n, 1),\n    \"twos\": partial(score_n, 2),\n    \"threes\": partial(score_n, 3),\n    \"fours\": partial(score_n, 4),\n    \"fives\": partial(score_n, 5),\n    \"sixes\": partial(score_n, 6),\n    \"one_pair\": partial(score_same, 2),\n    \"two_pairs\": score_two_pairs,\n    \"three_same\": partial(score_same, 3),\n    \"four_same\": partial(score_same, 4),\n    \"small_straight\": score_small_straight,\n    \"large_straight\": score_large_straight,\n    \"full_house\": score_full_house,\n    \"chance\": lambda x: sum(x),\n    \"yatzy\": score_yatzy,\n}\n\n\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 1))]\n\n\n\nfor cat in can_zero:\n    available_actions.append(Action(type=\"zero\", value=cat))\n    can_select = checkers[cat](state.dice_values)\n    if can_select:\n        available_actions.append(Action(type=\"score\", value=cat))\navailable_actions\n\n[Action(type='reroll', value=(0, 0, 0, 0, 0)),\n Action(type='reroll', value=(0, 0, 0, 0, 1)),\n Action(type='reroll', value=(0, 0, 0, 1, 1)),\n Action(type='reroll', value=(0, 0, 1, 1, 1)),\n Action(type='reroll', value=(0, 1, 1, 1, 1)),\n Action(type='reroll', value=(1, 1, 1, 1, 1)),\n Action(type='zero', value='two_pairs'),\n Action(type='zero', value='threes'),\n Action(type='score', value='threes'),\n Action(type='zero', value='small_straight'),\n Action(type='score', value='small_straight'),\n Action(type='zero', value='fours'),\n Action(type='score', value='fours'),\n Action(type='zero', value='four_same'),\n Action(type='zero', value='one_pair'),\n Action(type='zero', value='twos'),\n Action(type='score', value='twos'),\n Action(type='zero', value='ones'),\n Action(type='score', value='ones'),\n Action(type='zero', value='sixes'),\n Action(type='zero', value='three_same'),\n Action(type='zero', value='full_house'),\n Action(type='zero', value='fives'),\n Action(type='score', value='fives')]\n\n\nThats all actions I think for state. I need to stop and gather all my work together. I‚Äôm interested in Jeremy Howards nbdev approach. He keeps code in notebooks as literate programming. Basically coming up with the solutions is part of that, but the notebooks he has are very clean and straightforward. I guess he cleans them up thoroughly. How should I approach cleaning up this notebook to practice nbdev/solveit approach?\n\n\nü§ñReplyü§ñ\nGreat progress! You‚Äôve got all the key pieces working. For cleaning up in the nbdev/literate programming style, here‚Äôs an approach:\nKey principles: - Tell a story - each cell should build logically on the previous - Remove exploration/dead ends - keep only the path that works - Add explanatory text (in note cells) between code sections - Group related functions together - Show examples/tests that demonstrate how things work\nSuggested structure for your notebook:\n\nIntroduction note - what you‚Äôre building and why\nState and Action definitions (your dataclasses)\nCategory setup (the category set)\nHelper functions (has_ns, n_same, has_n_same, etc.)\nPattern checkers (two_pairs, full_house, straights)\nScoring functions\nChecker and scorer dictionaries\nAvailable actions function (combining your logic)\nExamples showing it working\n\nWould you like to start by identifying which cells to keep vs.¬†remove, or would you prefer guidance on how to add narrative notes between sections?",
    "crumbs": [
      "or"
    ]
  }
]