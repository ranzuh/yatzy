# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/yatzy_dup1.ipynb.

# %% auto 0
__all__ = ['categories', 'reroll_masks', 'score_fn', 'roll_n_dice', 'State', 'Action', 'score_ns', 'n_same', 'score_n_same',
           'score_two_pairs', 'score_full_house', 'score_small_straight', 'score_large_straight',
           'get_available_actions', 'reroll_masked', 'transition_func']

# %% ../nbs/yatzy_dup1.ipynb 5
import random
from dataclasses import dataclass
from typing import Literal
import itertools
from collections import Counter
from functools import partial

# %% ../nbs/yatzy_dup1.ipynb 6
# categories

categories = frozenset([
    "ones",
    "twos",
    "threes",
    "fours",
    "fives",
    "sixes",
    "one_pair",
    "two_pairs",
    "three_same",
    "four_same",
    "small_straight",
    "large_straight",
    "full_house",
    "chance",
    "yatzy",
])

# %% ../nbs/yatzy_dup1.ipynb 11
def roll_n_dice(n):
    return random.choices([1,2,3,4,5,6], k=n)

# %% ../nbs/yatzy_dup1.ipynb 16
@dataclass
class State:
    dice_values: tuple[int, ...]
    rolls_left: int
    categories_picked: frozenset[str]

# %% ../nbs/yatzy_dup1.ipynb 18
@dataclass
class Action:
    type: Literal["reroll", "score"]
    value: tuple[int, ...] | str

# %% ../nbs/yatzy_dup1.ipynb 21
reroll_masks = list(itertools.product((0,1), repeat=5))

# %% ../nbs/yatzy_dup1.ipynb 25
def score_ns(n, values):
    return n * values.count(n)

assert score_ns(3, (1,2,3,4,5)) == 3
assert score_ns(2, (2,2,2,3,3)) == 6
assert score_ns(6, (1,2,3,4,5)) == 0

# %% ../nbs/yatzy_dup1.ipynb 26
def n_same(n, values):
    counts = Counter(values)
    return [k for k, v in counts.items() if v >= n]

assert n_same(2, (1,2,2,3,3)) == [2, 3]
assert n_same(2, (1,2,3,4,5)) == []

def score_n_same(n, values):
    sames = n_same(2, values)
    if len(sames) == 0: return 0
    return n * max(sames)

assert score_n_same(2, (3,3,4,4,6)) == 8
assert score_n_same(2, (1,2,3,4,6)) == 0

# %% ../nbs/yatzy_dup1.ipynb 27
def score_two_pairs(values):
    pairs = n_same(2, values)
    if len(pairs) == 2:
        return 2 * sum(pairs)
    return 0

assert score_two_pairs((1,1,2,2,3)) == 6
assert score_two_pairs((1,1,2,3,4)) == 0
assert score_two_pairs((1,1,1,1,2)) == 0

# %% ../nbs/yatzy_dup1.ipynb 28
def score_full_house(values):
    pairs = n_same(2, values)
    three_sames = n_same(3, values)
    if pairs and three_sames:
        pairs.remove(three_sames[0])
        if len(pairs) > 0: return sum(values)
    return 0

assert score_full_house((2,2,3,3,3)) == 13
assert score_full_house((1,2,3,3,3)) == 0

# %% ../nbs/yatzy_dup1.ipynb 29
def score_small_straight(values):
    return sum(values) if values == (1,2,3,4,5) else 0

def score_large_straight(values):
    return sum(values) if values == (2,3,4,5,6) else 0

assert score_small_straight((1,2,3,4,5)) == 15
assert score_large_straight((2,3,4,5,6)) == 20

# %% ../nbs/yatzy_dup1.ipynb 30
score_fn = {
    "ones": partial(score_ns, 1),
    "twos": partial(score_ns, 2),
    "threes": partial(score_ns, 3),
    "fours": partial(score_ns, 4),
    "fives": partial(score_ns, 5),
    "sixes": partial(score_ns, 6),
    "one_pair": partial(score_n_same, 2),
    "two_pairs": score_two_pairs,
    "three_same": partial(score_n_same, 3),
    "four_same": partial(score_n_same, 4),
    "small_straight": score_small_straight,
    "large_straight": score_large_straight,
    "full_house": score_full_house,
    "chance": lambda x: sum(x),
    "yatzy": partial(score_n_same, 5),
}

# %% ../nbs/yatzy_dup1.ipynb 34
def get_available_actions(state: State) -> list[Action]:
    available_actions = []
    if state.rolls_left > 0:
        rerolls = [Action("reroll", mask) for mask in reroll_masks]
        available_actions.extend(rerolls)
    
    can_select = categories - state.categories_picked
    for cat in can_select:
        score = score_fn[cat](state.dice_values)
        if can_select:
            available_actions.append(Action(type="score", value=cat))
    
    return available_actions

# %% ../nbs/yatzy_dup1.ipynb 41
def reroll_masked(values, mask):
    next_values = list(values)
    reroll = roll_n_dice(5)
    for i, bit in enumerate(mask):
        if bit == 1:
            next_values[i] = reroll[i]
    return tuple(sorted(next_values))

# %% ../nbs/yatzy_dup1.ipynb 43
def transition_func(state: State, action: Action):
    match action.type:
        case "reroll":
            assert state.rolls_left > 0
            new_values = reroll_masked(state.dice_values, action.value)
            return State(new_values, state.rolls_left - 1, state.categories_picked)
        case "score":
            assert action.value not in state.categories_picked
            new_categories = state.categories_picked | {action.value}
            categories_left = categories - state.categories_picked
            # TODO: scoreboard stuff
            if not categories_left: return TERMINAL_STATE
            new_values = tuple(sorted(roll_n_dice(5)))
            return State(new_values, 2, frozenset(new_categories))

